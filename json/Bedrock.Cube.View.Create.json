{"Parameters": [{"Prompt": "Cube Name", "Type": "String", "Value": "", "Name": "pCube"}, {"Prompt": "Name of the View", "Type": "String", "Value": "", "Name": "pView"}, {"Prompt": "Filter: Year: 2006 + 2007 & Scenario: Actual + Budget & Organization: North America Operations", "Type": "String", "Value": "", "Name": "pFilter"}, {"Prompt": "Suppress Zero Data (Skip = 1)", "Type": "Numeric", "Value": 1, "Name": "pSuppressZero"}, {"Prompt": "Suppress Consolidations (Skip = 1)", "Type": "Numeric", "Value": 1, "Name": "pSuppressConsol"}, {"Prompt": "Suppress Rules (Skip = 1)", "Type": "Numeric", "Value": 1, "Name": "pSuppressRules"}, {"Prompt": "Delimiter for start of Dimension/Element set", "Type": "String", "Value": "&", "Name": "pDimensionDelim"}, {"Prompt": "Delimiter for start of element list", "Type": "String", "Value": ":", "Name": "pElementStartDelim"}, {"Prompt": "Delimiter between elements", "Type": "String", "Value": "+", "Name": "pElementDelim"}, {"Prompt": "Debug: 0", "Type": "Numeric", "Value": 0, "Name": "pDebug"}], "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n", "Variables": [], "HasSecurityAccess": true, "UIData": "CubeAction=1511\fDataAction=1503\fCubeLogChanges=0\f", "Name": "Bedrock.Cube.View.Create", "PrologProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#####################################################################################\r\n##~~Copyright bedrocktm1.org 2011 www.bedrocktm1.org/how-to-licence.php Ver 3.0.2~~##\r\n#####################################################################################\r\n\r\n# This process automatically creates a view that can be used for exporting, copying and zeroing out numbers.\r\n\r\n# Note:\r\n# - The pFilter parameter contains the dimenson and elements to be used for filtering.\r\n# - The format of the pFilter parameter is as follows delimiters of :, & and +:\r\n#     Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4\r\n# - The dimension parameters do not need to be given in the index order of dimensions in the cube.\r\n# - The dimension name is specified as the first member of the delimited string of elements.\r\n# - If consols are skipped the N level children of any consolidated filter elements will be used\r\n# - Spaces are ignored so use them to make your filter more readable\r\n\r\n\r\n### Constants ###\r\n\r\ncProcess = 'Bedrock.Cube.View.Create';\r\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\nsRandomInt = NumberToString( INT( RAND( ) * 1000 ));\r\ncDebugFile = GetProcessErrorFileDirectory | cProcess | '.' | cTimeStamp | '.' | sRandomInt ;\r\nsSubset = pView;\r\nsDelimDim = TRIM(pDimensionDelim);\r\nsElementStartDelim = TRIM(pElementStartDelim);\r\nsDelimElem = TRIM(pElementDelim);\r\nnErrors = 0;\r\n\r\n\r\n### Initialise Debug ###\r\n\r\nIf( pDebug >= 1 );\r\n\r\n  # Set debug file name\r\n  sDebugFile = cDebugFile | 'Prolog.debug';\r\n\r\n  # Log start time\r\n  AsciiOutput( sDebugFile, 'Process Started: ' | TimSt( Now, '\\d-\\m-\\Y \\h:\\i:\\s' ) );\r\n\r\n  # Log parameters\r\n  AsciiOutput( sDebugFile, 'Parameters: pCube:              ' | pCube );\r\n  AsciiOutput( sDebugFile, '            pView:              ' | pView );\r\n  AsciiOutput( sDebugFile, '            pFilter:            ' | pFilter );\r\n  AsciiOutput( sDebugFile, '            pSuppressZero:      ' | NumberToString( pSuppressZero) );\r\n  AsciiOutput( sDebugFile, '            pSuppressConsol:    ' | NumberToString( pSuppressConsol) );\r\n  AsciiOutput( sDebugFile, '            pSuppressRules:     ' | NumberToString( pSuppressRules) );\r\n  AsciiOutput( sDebugFile, '            pDimensionDelim:    ' | pDimensionDelim );\r\n  AsciiOutput( sDebugFile, '            pElementStartDelim: ' | pElementStartDelim );\r\n  AsciiOutput( sDebugFile, '            pElementDelim:      ' | pElementDelim );\r\n\r\nEndIf;\r\n\r\n# If specified cube does not exist then terminate process\r\nIf( CubeExists(   pCube   ) = 0 );\r\n  sMessage = 'Cube: ' | pCube | ' does not exist';\r\n  If( pDebug >= 1 );\r\n    AsciiOutput( sDebugFile, sMessage );\r\n  EndIf;\r\n  nErrors = nErrors + 1;\r\n  ProcessQuit;\r\nEndIf;\r\n\r\n## Validate the View parameter\r\nIf( TRIM(pView) @= '' );\r\n  sMessage = 'A view name must be provided';\r\n  If( pDebug >= 1 );\r\n    AsciiOutput( sDebugFile, sMessage );\r\n  EndIf;\r\n  nErrors = nErrors + 1;\r\n  ProcessQuit;\r\nEndIf;\r\n\r\n# Check the delimiters\r\nIf( sDelimDim @= '' );\r\n  sMessage = 'The dimension delimiter is blank';\r\n  If( pDebug >= 1 );\r\n    AsciiOutput( sDebugFile, sMessage );\r\n  EndIf;\r\n  ProcessQuit;\r\nEndIf;\r\n\r\nIf( sElementStartDelim @= '' );\r\n  sMessage = 'The dimension name delimiter is blank';\r\n  If( pDebug >= 1 );\r\n    AsciiOutput( sDebugFile, sMessage );\r\n  EndIf;\r\n  ProcessQuit;\r\nEndIf;\r\n\r\nIf( sDelimElem @= '' );\r\n  sMessage = 'The element delimiter is blank';\r\n  If( pDebug >= 1 );\r\n    AsciiOutput( sDebugFile, sMessage );\r\n  EndIf;\r\n  ProcessQuit;\r\nEndIf;\r\n\r\nIf( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim @= sDelimElem );\r\n  sMessage = 'The delimiters cannot me the same';\r\n  If( pDebug >= 1 );\r\n    AsciiOutput( sDebugFile, sMessage );\r\n  EndIf;\r\n  ProcessQuit;  \r\nEndIf;\r\n\r\n### Create View ###\r\nIf ( pDebug >= 1 );\r\n     AsciiOutput( sDebugFile, 'Creating view ' | pView | ' on cube ' | pCube );\r\nEndIf;\r\nIf( pDebug <= 1 );\r\n    If( ViewExists( pCube, pView ) = 1 );\r\n        # Clear all of the subsets that may be attached to the view\r\n        nCount = 1;\r\n        While( TabDim( pCube, nCount ) @<> '' );\r\n          sCubeDimName = TabDim( pCube, nCount );\r\n          # Subset is the same name as the view\r\n          If( SubsetExists( sCubeDimName, pView ) = 1 );\r\n            # Clear the elements\r\n            SubsetDeleteAllElements( sCubeDimName, pView );\r\n            # Add all elements\r\n            If( SubsetIsAllSet(sCubeDimName, pView, 1) <> 1 );\r\n              If( pDebug >= 1 );\r\n                AsciiOutput( sDebugFile, 'Unable to add all elements on subset ' | pView | ' on dimension ' | sCubeDimName );\r\n              EndIf;\r\n              ProcessQuit;\r\n            EndIf;\r\n          ENDIF;\r\n          nCount = nCount + 1;\r\n        End;\r\n    Else;\r\n        ViewCreate( pCube, pView );\r\n    EndIf;\r\n\r\n    ViewExtractSkipCalcsSet( pCube, pView, pSuppressConsol );\r\n    ViewExtractSkipZeroesSet( pCube, pView, pSuppressZero );\r\n    ViewExtractSkipRuleValuesSet( pCube, pView, pSuppressRules );\r\nEndIf;\r\n\r\n### Split filter and create subsets ###\r\nsFilter = TRIM( pFilter );\r\nnChar = 1;\r\nnCharCount = LONG( sFilter );\r\nsWord = '';\r\nsLastDelim = '';\r\nnIndex = 1;\r\n# Add a trailing element delimiter so that the last element is picked up\r\nIf( nCharCount > 0 );\r\n  sFilter = sFilter | sDelimElem;\r\n  nCharCount = nCharCount + LONG(sDelimElem);\r\nEndIf;\r\nWHILE (nChar <= nCharCount);\r\n\r\n    sChar = SUBST( sFilter, nChar, 1);\r\n    If( pDebug >= 1 );\r\n      sMessage = 'Next character is: ' | sChar | ' at ' | NumberToString(nChar);\r\n      AsciiOutput( sDebugFile, sMessage );\r\n    EndIf;\r\n\r\n    # Used for delimiters, required for multiple character dilimiters\r\n    sDelim = '';\r\n    nAddExtra = 0;\r\n\r\n    # Ignore spaces\r\n    IF (TRIM(sChar) @<> '' );\r\n\r\n\r\n      ### Dimension Name ###\r\n\r\n      # If the delimiter is more than 1 character peek ahead the same amount\r\n      # Ignore the first character\r\n      sDelim = sChar;\r\n      nCount = LONG(sElementStartDelim) - 1;\r\n      If( nCount > 0 & nChar + nCount <= nCharCount );\r\n        # Add the extra characters\r\n        sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\r\n        # Move to the end of the delimter\r\n        nAddExtra = nCount;\r\n      EndIf;\r\n\r\n      If( sDelim @= sElementStartDelim );\r\n\r\n        sChar = sDelim;\r\n\r\n        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\r\n            sMessage = 'The name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\r\n            If( pDebug >= 1 );\r\n              AsciiOutput( sDebugFile, sMessage );\r\n            EndIf;\r\n            ProcessQuit;\r\n        EndIf;\r\n\r\n        sDimension = sWord;\r\n\r\n        If( pDebug >= 1 );\r\n          sMessage = 'Found dimension name: ' | sDimension | ' at ' | NumberToString(nChar);\r\n          AsciiOutput( sDebugFile, sMessage );\r\n        EndIf;\r\n\r\n        If( DimensionExists( sDimension ) = 0 );\r\n            # The dimension does not exist in the model. Cancel process\r\n            sMessage = 'Dimension: ' | sDimension | ' does not exist';\r\n            If( pDebug >= 1 );\r\n              AsciiOutput( sDebugFile, sMessage );\r\n            EndIf;\r\n            nErrors = nErrors + 1;\r\n            ProcessQuit;\r\n        EndIf;\r\n\r\n        ### Determine the dimension is a member of the cube ###\r\n        nCount = 1;\r\n        nDimensionIndex = 0;\r\n        While( TabDim( pCube, nCount ) @<> '' );\r\n          sCubeDimName = TabDim( pCube, nCount );\r\n          IF(\r\n          sDimension @= sCubeDimName);\r\n            nDimensionIndex = nCount;\r\n          ENDIF;\r\n          nCount = nCount + 1;\r\n        End;\r\n\r\n        If( nDimensionIndex = 0 );\r\n            # The dimension does not exist in the cube. Cancel process\r\n            sMessage = 'Dimension: ' | sDimension | ' is not a member of: '| pCube | 'cube.';\r\n            If( pDebug >= 1 );\r\n              AsciiOutput( sDebugFile, sMessage );\r\n            EndIf;\r\n            nErrors = nErrors + 1;\r\n            ProcessQuit;\r\n        EndIf;\r\n\r\n        # Create the subset\r\n        If( SubsetExists( sDimension, sSubset ) = 1 );\r\n            If ( pDebug >= 1 );\r\n                 AsciiOutput( sDebugFile, 'Subset ' | sSubset | ' exists on dimension ' | sDimension | '. Deleting all elements' );\r\n            EndIf;\r\n            If( pDebug <= 1 );\r\n                SubsetDeleteAllElements( sDimension, sSubset );\r\n            EndIf;\r\n        Else;\r\n            If ( pDebug >= 1 );\r\n                 AsciiOutput( sDebugFile, 'Creating subset ' | sSubset | ' on dimension ' | sDimension );\r\n            EndIf;\r\n            If( pDebug <= 1 );\r\n                SubsetCreate( sDimension, sSubset );\r\n            EndIf;\r\n        EndIf;\r\n\r\n        # Attach to the view\r\n        If ( pDebug >= 1 );\r\n             AsciiOutput( sDebugFile, 'Assigning subset ' | sSubset | ' to view ' | pView );\r\n        EndIf;\r\n        If( pDebug <= 1 );\r\n            ViewSubsetAssign(pCube, pView, sDimension, sSubset);\r\n        EndIf;\r\n\r\n        nIndex = 1;\r\n\r\n        sLastDelim = sChar;\r\n        # Clear the word\r\n        sWord = '';\r\n      Else;\r\n\r\n        # Reset extra chars\r\n        nAddExtra = 0;\r\n\r\n        ### Check both both dim delimiter and element delimiter ###\r\n        nIsDelimiter = 0;\r\n\r\n        ## Check dimension delimiter first\r\n        # If the delimiter is more than 1 character peek ahead the same amount\r\n        # Ignore the first character\r\n        sDelim = sChar;\r\n        nCount = LONG(sDelimDim) - 1;\r\n        If( nCount > 0 & nChar + nCount <= nCharCount );\r\n          # Add the extra characters\r\n          sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\r\n          # Move to the end of the delimter\r\n          nAddExtra = nCount;\r\n        EndIf;\r\n\r\n        If( sDelim @= sDelimDim );\r\n          nIsDelimiter = 1;\r\n          sChar = sDelim;\r\n        Else;\r\n          # Reset extra chars\r\n          nAddExtra = 0;\r\n\r\n          ## Check element delimiter\r\n\r\n          # If the delimiter is more than 1 character peek ahead the same amount\r\n          # Ignore the first character\r\n          sDelim = sChar;\r\n          nCount = LONG(sDelimElem) - 1;\r\n          If( nCount > 0 & nChar + nCount <= nCharCount );\r\n            # Add the extra characters\r\n            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\r\n            # Move to the end of the delimter\r\n            nAddExtra = nCount;\r\n          EndIf;\r\n\r\n          If( sDelim @= sDelimElem );\r\n            nIsDelimiter = 1;\r\n            sChar = sDelim;\r\n          Else;\r\n            # Reset extra chars\r\n            nAddExtra = 0;\r\n          EndIf;\r\n\r\n        EndIf;\r\n\r\n        If ( nIsDelimiter = 1 );\r\n\r\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\r\n            sMessage = 'An element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\r\n            If( pDebug >= 1 );\r\n              AsciiOutput( sDebugFile, sMessage );\r\n            EndIf;\r\n            ProcessQuit;\r\n          EndIf;\r\n\r\n          sElement = sWord;\r\n\r\n          If( pDebug >= 1 );\r\n            sMessage = 'Inserting element: ' | sElement | ' at ' | NumberToString(nChar);\r\n            AsciiOutput( sDebugFile, sMessage );\r\n          EndIf;\r\n\r\n          If( DIMIX( sDimension, sElement ) = 0 );\r\n              # The element does not exist in the dimension. Cancel process\r\n              sMessage = 'Element: ' | sElement | ' in dimension ' | sDimension | ' does not exist';\r\n              If( pDebug >= 1 );\r\n                AsciiOutput( sDebugFile, sMessage );\r\n              EndIf;\r\n              nErrors = nErrors + 1;\r\n              ProcessQuit;\r\n          EndIf;\r\n\r\n\r\n          If ( pSuppressConsol = 1 & DTYPE( sDimension, sElement) @= 'C'  );\r\n              # Add all N level elements to the subset\r\n              # Loop through all elements and check if it is an ancestor\r\n              If ( pDebug >= 1 );\r\n                  AsciiOutput( sDebugFile, 'Element ' | sElement | ' is consolidated' );\r\n              EndIf;\r\n              nElCount = DIMSIZ ( sDimension );\r\n              n = 1;\r\n              WHILE ( n <= nElCount );\r\n                  sEl = DIMNM( sDimension, n );\r\n                  IF( DTYPE( sDimension, sEl) @<> 'C' & ELISANC( sDimension, sElement, sEl ) = 1 );\r\n\r\n                      If ( pDebug >= 1 );\r\n                          AsciiOutput( sDebugFile, 'Inserting element ' | sEl | ' into subset ' | sSubset | ' on dimension ' | sDimension);\r\n                      EndIf;\r\n                      If( pDebug <= 1 );\r\n                          SubsetElementInsert( sDimension, sSubset, sEl, nIndex );\r\n                      EndIf;\r\n                  EndIf;\r\n                  n = n + 1;\r\n              END;\r\n\r\n          Else;\r\n              # Add the element to the subset\r\n              If ( pDebug >= 1 );\r\n                  AsciiOutput( sDebugFile, 'Inserting element ' | sElement | ' into subset ' | sSubset | ' on dimension ' | sDimension);\r\n              EndIf;\r\n              If( pDebug <= 1 );\r\n                  SubsetElementInsert( sDimension, sSubset, sElement, nIndex );\r\n              EndIf;\r\n          EndIf;\r\n\r\n          nIndex = nIndex + 1;\r\n\r\n          sLastDelim = sChar;\r\n\r\n          # Clear the word\r\n          sWord = '';\r\n        Else;\r\n          sWord = sWord | sChar;\r\n        EndIf;\r\n\r\n      EndIf;\r\n\r\n    EndIf;\r\n\r\n    nChar = nChar + nAddExtra + 1;\r\n\r\n    If( pDebug >= 1 );\r\n      sMessage = 'Current word is: ' | sWord | ' at ' | NumberToString(nChar - 1);\r\n      AsciiOutput( sDebugFile, sMessage );\r\n    EndIf;\r\n\r\n\r\nEND;\r\n\r\n\r\n\r\n\r\n", "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n", "DataSource": {"Type": "None"}, "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#####################################################################################\r\n##~~Copyright bedrocktm1.org 2011 www.bedrocktm1.org/how-to-licence.php Ver 3.0.2~~##\r\n#####################################################################################\r\n\r\n\r\n### Initialise Debug ###\r\n\r\nIf( pDebug >= 1 );\r\n\r\n  # Set debug file name\r\n  sDebugFile = cDebugFile | 'Epilog.debug';\r\n\r\n  # Log errors\r\n  If( nErrors <> 0 );\r\n    AsciiOutput( sDebugFile, 'Errors Occurred' );\r\n  EndIf;\r\n\r\n  # Log finish time\r\n  AsciiOutput( sDebugFile, 'Process Finished: ' | TimSt( Now, '\\d-\\m-\\Y \\h:\\i:\\s' ) );\r\n\r\nEndIf;\r\n\r\n\r\n### If errors occurred terminate process with a major error status ###\r\n\r\nIf( nErrors <> 0 );\r\n  ProcessQuit;\r\nEndIf;\r\n\r\n\r\n### End Epilog ###\r\n\r\n\r\n\r\n\r\n", "VariablesUIData": []}